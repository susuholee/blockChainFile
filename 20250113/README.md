# 자바스크립트 배열, 함수, 실행 컨텓스트

## 자바스크립트의 참조 타입
> object, array, Map, Set 

## 자바스크립트의 메모리
> call stack과 heap이라는 메모리 영역이 있고
> 원시타입은 call stack에 저장이 되었고
> 참조 타입은 heap메모리에 저장이 된다.

- 원시타입 : 불변성을 가지고 새로운 데이터가 재할당되면 이전의 주소를 새로운 값의 주소로 변경하고 
            이전 주소는 이후에 해제 된다.

- 참조타입 : 주소를 가르키는 주소의 값이 있고 값을 변경할 때 heap 메모리에서 참조되고 있는 주소의 
            값이 변경된다. 참조타입은 원시타입과 다르게 변수의 크기가 동적으로 변할 수 있다.

## 배열의 문법

```js
[예약어] [변수명] = [];  // 배열을 표현하는 구문 [];

// 객체는 하나의 사물을 표현할 때
// 리스트의 형태를 표현할 때

// 다른 언어와 다르게 자바스크립트의 배열은 동적인 타입이 모두 할당될 수 있다.

const arr = [1, "2", true, undefined, null, {} ]; // 자바스크립트의 배열의 타입은 정해져있지 않고 동적인 타입을 모두 할당할 수 있다.
// 자바스킙트의 배열은 객체라고 보면 된다. -> 객체와 비슷하다고 보면 된다.

// 이중 배열 
const arr = [1, 2, 3,];
// index를 표현할 때 0부터 시작한다.
// 0에서 부터 숫자를 세어나가면 된다.
// 0번 부터 배열의 안에 들어있는 값의 순서로 인덱스틀 참조한다.

// 이전에 배웠던 객체의 형태
const object = {
    name : "soon"
}

// 객체안의 값을 호출할 때
object.name === "soon";
object["soon"]

// 배열의 값을 호출할 때 인덱스 번호로 접근한다.
arr[0] === 1 // 0번 인덱스의 값은 1
arr[1] === 2 // 1번 인덱스의 값은 2
arr[2] === 3 // 2번 인덱스의 값은 3
arr[3] === 4 // 2번 인덱스의 값은 3
// 배열에 값을 추가할 때
// 이미 값을 가지고 있는 인덱스에는 재할당을 통해서 해줘도 된다.
// 배열의 맨뒤나 앞에 값을 추가할 때
// push() 라는 메서드를 사용해서 

arr.push(4);
// 메서드는 함수를 배우지 않아서 
// 메서드 : 객체에 포함된 기능들 함수
// 객체안에 포함된 함수는 메서드
// 외부에 생성한 함수를 함수


// push() : 배열에다 새로운 값을 맨끝에다가  추가
// 맨뒤에 4라는 값을 추가한것.

arr === [1,2,3,4]

// 배열의 갯수를 확인하는 키값
arr.length() // 배열의 길이를 호출하는 키
arr.length === // arr 배열의 길이는 4

 for(let i = 0; i <= 100 i++){
    arr.push(i); 
 }

 [1,2,3,4,5,6,7,8 ... 100]
 
 // 컨텐츠를 만드는데 제목이 5개가 필요하다. 숫자의 표현이 들어간다.

  for(let i = 0; i <= 100 i++){
    arr.push(i + "번째 제목"); 
 }

["1번째 제목","2번째 제목" ... "5번째 제목" ]

for(let i = 1; i <= 5; i++){
    const object = {
        title : i +"번째 제목",
        content : i + "번째 컨텐츠"
    }
    arr.push(object);
}

[{title : "1번째 제목", content : "1번째 컨텐츠"}, ...]

// 게시글들의 내용을 배열에 담아서 표현
// 배열은 여러가지 갯수가 많은 데이터를 다룰 때 용이하다.

arr[2] === {title : "3번째 제목", content : "3번째 콘텐츠"}


// 배열의 갯수만큼 호출하면서 사용해야한다.
// 0 100의 인덱스 접근 0~99
for(let i = 0; i < arr.length; i++){
    // DOM(HTML 태그) 요소 제어 부분은 나중에
    // 예를 들어서 DOM제어를 한다
    // 새로운 요소를 만들면서 만들어줄 예정
    // 예시만 들은 것.
    myTag.InnerHTML = arr[i].title + " | " + arr[i].content; 
}

```

 ### `참조 타입의 깇은 복사 얕은 복사` 면접 단골 질문
 - 얕은 복사 : 값을 복사하는 방식 -> 참조타입의 주소를 복사하는 방식
 - 깉은 복사 : 값을 복사하는 방식 -> 참조타입의 값을 복사하는 방식
```js 
    const a =[1];
    const b =[1];
  
    // 참조 타입은 주소를 가르키는 주소
    // 값은 heap이라는 메모리 공간에 저장이 되고
    // 주소를 변수가 가르키게 된다.
    console.log(a === b); // false를 반환한다. 왜?  a의 주소랑 b의 주소가 각각 다르기 때문

    const c = a;
    // a 변수의 주소를 복사해서 사용한 것 
    // 할당된것이 주소
    // 같은 주소를 바라보고 있기 때문에 c에서 가르키는 주소의 값을 변경하면 a의 바라보고 있는 주소의 값이 바뀐다.
    // 얕은 복사가 일어난 것.
    console.log( c === a);
    c.push(2);
    console.log(a); // 값을 복사한게 아니고 주소를 복사한 것

    // 깊은 복사
    // 값만을 복사한 것
    
    // 배열을 초기화 
    // ...(스프레드 연산자) : 참조타입의 깊은 복사를 하는 구문 객체 또는 배열의 값을 깊은 복사해온다.
    // 배열이나 객체의 내용을 풀어해친다.
    // 값만 복사한 경우 깊은복사.
    const d = [...a]; 
    console.log(d === a);

    // 페이지 구현할 때 검색어를 쳤는데
    // 프론트에서 모든 글의 제어를 다룬다고 가정하고
    // 전체글의 배열을 가지고 있는데
    // 검색어 검색을 했더니 원본배열에서 검색어에 관련된 값만 놔두고 원본 배열을 수정했다.
    // 모든글 텝으로 이동하니 전체글이 보이지 않게 된다.
    
    // 요소의 내용을 노드 유사 배열
    // 요소의 배열을 복사해서 붙여넣기 하고 싶어서 해당 원본 요소가 이동되면 안돼겠지?.
 ```