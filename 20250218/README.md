# Nodejs

> 자바스크립트 런타임 환경을 제공한다. (자바스크립트 기반)
> 브라우저와 다른 런타임 환경
> 여러 OS에서 실행이 가능하다. 윈도우, 맥, 리눅스
> 2009년도에 nodejs가 출시하면서 2010년에 npm이 출시됨
> 지속적으로 업데이트를 하고 있고 탄생하고 2년뒤에 대형 플랫폼에서 사용하기 시작하면서 인기를 끌게 됨
> 20년도 쯤에 gitHub npm을 인수 등
> nodejs를 사용하는 기업이 많이 증가했다.
> 서버 구축에 정말 많이 사용되는 마이크로 서비스 아키텍처를 설계하는데 중요한 역할을 하는 엔진
> 마이크로 서비스 아키텍처 : 애플리케이션을 여러 개의 작은 서비스로 나누어 개발하는 방식

## nodejs 등장

> 자바스크립트로 서버 로직 즉, 서버측 활용이 가능한 시작은 nodejs (javascript B8 엔진)

## nodejs의 인기

> nodejs 싱글 스레드(사실상 멀티 스레드) 자바스크립트를 활용한 서버측 로직을 작성하기 위해서 비동기 이벤트 기반 아키텍처를 사용 성능이 좋고 확장성을 제공한다.

## nodejs가 서버?

> nodejs는 자체가 서버가 아니고 웹서버를 구축할 수 있는 로직을 작성할 수 있게 해주는 엔진
> javascript를 배워서 javascript로 서버로직 코드를 작성할 수 있다.
> npm(node package manager) : 개발자들이 본인의 소스코드를 공유할 수 있는 패키지 저장소
> 방대한 오픈 소스 생태계를 구축하기 위해서 개발자들이 편하게 개발을 할 수 있도록 개발 생산성을 향상시키는 목적도 가지고 있다.

## nodejs javascript V8 엔진

> 크롬에서 개발한 javascript V8 엔진으로 빌드된 서버측 자바스크립트 런타임 환경
> 브라우저와 런타임 환경이 다르다.
> 여기서 `빌드`가 되었다는 것은 구글에서 개발한 V8 엔진을 사용해서 코드를 컴파일러를 통해 실행 파일로 변환하는 작업

## nodejs의 블로킹 논블로킹

> nodejs에서 `비동기 I/O` 작업을 진행할 때 또 다른 작업을 할 수 있도록 제공한다 리버브(nodejs의 장점)
> 파일의 I/O 작업이 완료될 때까지 기다리면서 다른 코드도 실행할 수 있다.
> Input/Output : 파일 시스템 (브라우저에서는 파일을 조작할 수 없다.) 네트워크 디스크 등 데이터를 읽거나 쓰거나 하는 작업은 무거운 작업인데 nodejs는 이러한 작업의 속도가 빠르다.

> 논블로킹 I/O 작업을 할때 다른 코드의 내용을 실행할 수 있도록 해준다.
> nodejs는 모든 I/O 작업을 비동기적으로 실행하고 블로킹 하지 않는다.

## nodejs 이벤트 기반의 아키텍처

> 이벤트 기반의 프로그래밍은 이벤트가 발생하면 콜백 함수를 실행하는 방식
> 자바스크립트로 이벤트 기반의 프로그래밍을 선택한 이유 : 비동기 처리가 가능하고 좋은 성능과 확장성을 가질 수 있기 때문

## 이벤트 기반

> 이벤트가 실행되면 이벤트로 등록한 함수 즉, 작업을 수행한다.
> `이벤트 리스너에 콜백 함수를 등록한다.`

## nodejs의 이벤트 루프

> nodejs 싱글 스레드 기반의 비동기 처리 모델을 사용한다. 내부적으로는 멀티 스레드와 같이 동작한다.

### 브라우저의 이벤트 동작 방식

// settimeout

> 실행 컨텍스트 -> web api -> 테스크 큐 -> 콜스택 내용 X -> 이벤트 루프 -> 실행

```js
setTimout(() => {
  console.log("1초 됬다");
}, 1000);
console.log("시작");
```
### nodejs의 이벤트 루프의 동작 방식
> 비동기 작업에 콜백함수를 등록하고 완료된 작업을 실행하는 역할

1. 타이머를 확인한다 : setTimeout() 같은 함수의 실행 시간을 감지, 비동기 작업이 처리가 되었는지
2. I/O 이벤트의 처리 : 파일을 읽거나 네트워크에 요청이 완료되었는지 확인한 뒤에 완료가 되면 콜백 함수를 실행한다. (poll 단계에서 대기 중인 콜백(I/O)를 실행한다. 이벤트 루프가 I/O 작업이 완료되지 않으면 콜백은 대기상태) (비동기 I/O 작업이 완료되면 I/O 콜백 큐에 추가되고 콜스택이 모두 비워지면 실행된다.)
```js

```

3. idle/Prepare : 내부적으로 사용하는 단계이고 개발자가 직접 제어는 하지 않는다.
poll 단계 이벤트 루프의 핵심 단계 비동기 I/O 작업이 완료되면 I/O 콜백 큐에서 확인하고 콜백을 처리한다.
대기중인 콜백이 없는지를 확인하는 단계, 비동기 작업이 완료되면 콜백을 호출해서 알려준다.
대기중인 이벤트가 없으면 이벤트가 발생할때 까지 기다린다.

4. Pendding Callbacks : 일부 시스템의 관련 콜백의 내용이 실행되는 단계
우리가 등록한 콜백의 내용을 호출하는 단계 setImmdiate가 poll 단계가 끝나면 바로 실행이 되는데
setImmdiate가 등록한 콜백을 바로 호출한다.
5. Immediate 콜백의 처리 : setImmdiate로 예약된 콜백들이 실행된다.


6. close 이벤트 : 닫는 이벤트를 처리한다.
리소스의 내용이 닫힐때 실행되는 콜백이 여기서 호출한다.

### nodejs 스레드
#### 스레드
> 내부적으로 실행되는 작은 작업의 단위
> 프로그램을 실행할때 여러개의 스레드를 사용해서 병렬로 작업을 처리할 수 있다.(멀티 스레드)

### nodejs의 워커 스레드
nodejs가 기본적으로 단일 스레드이기 때문에
nodejs의 10 버전 이후에 생성된 worker_threads 모듈을 사용해서 멀티스레드 환경을 제공한다.
단일 스레드라서 CPU가 작업을 너무 집중시켜서 사용하게 되면 이벤트 루프가 터짐
worker_threads를 사용해서 여러개의 스레드에서 무거운 작업을 나눠서 작업한다.

### 워커 스레드와 libuv
> nodejs의 메인 스레드가 단일 스레드가 libuv는 c++로 구현된 라이브러리이고 이 라이브러리가 하는 일이
> 여러개의 백그라운드 스레드를 생성하는 역할
> 워커스레드 들은 각각 이벤트 루프 처리를 할 수 있다.
> 워커스레드는 독립된 코드의 실행이 가능, 실행 컨텍스트가 생성성
> 백그라운드의 스레드 방식은 libuv가 I/O 작업을 처리하기 위해 기본으로 4개의 백그라운드 스레드를 생성한다.

### 백그라운드
> 핸드폰에서 노래를 틀고 다른 앱을 사용하는 것처럼
> 백그라운드에서 동작한다. `실행되는 작업이 프로세스에 올라가있는 프로그램이 사용자가 조작을 하지 않아도 동작을 하고 있다` 라는 뜻

### nodejs 설치


### nodejs 문법
> nodejs 레포 모드
> nodejs에서 제공하는 인터페이스

```sh
# 레포 모드 진입
# Repl (Read evaluation print loop)
# 읽기 - 해석(실행) - 출력 - 반복
# 대기 상태에서 이벤트를 기다린다.
node

# nodejs의 전역 객체는 global 객체
# console.log()의 메서드도 global 객체에 포함되어 있다.
# 브라우저의 window 객체에 포함되어있는 메서드와 동일하게 보면 안되지만
# 비슷한 동적을 하고 이름이 같은 메서드가 있는 것
# 런타임 환경이 다르기 때문에
# 브라우저에서도 자바스크립트를 해석할 수 있고 실행환경을 제공한 것 
# nodejs에서도 자바스크립트를 해석하고 실행환경을 제공한다.

# 컨트롤 + C
# 레포 모드 종료
```
```js
// 각각의 파일을 모듈화 해서 사용한다.
// 쉬운표현으로 기능을 하나의 묶음으로 표현했다고 보면
// 프로그램을 개발할 때 가장 작은 단위
// 모듈화 각각 파일을 단위로 구분하고 파일의 내용에 필요한 공통된 기능들이 포함되어 있는 것.

// 로또라는 기능을 모듈화 했다
// 로또의 모든 기능과 사용되는 변수를 하나의 파일로 내보내서 모듈화 시켰다.
// `모듈화`

const blockClass = [
  {
    name : "soon",
    age : 20,
    comment() { // 메소드 축약형을 쓰는 이유 :  function을 사용하면 불필요한 생성자의 내용까지 포함되기 때문에 
      console.log("안녕");
    }
  },
  {
    name : "kim",
    age : 30,
    comment() {
      console.log(`안녕 ${this.name} 이야`) // name의 키를 가져와서 this가 바인딩된다.
    }
  }
]

// 내보내고 싶은 내용
module.exports = blockClass; 
```
### 오늘은 중요한 부분 모듈화 nodejs의 스코프

### nodejs 모듈 레퍼
```js
( 
    function(exports, require, module, filename ...) {
        // 우리가 작성하는 코드들이 이 영역에 포함된다.
        // 이 레퍼라는 것 때문에 각각의 파일들이 독립된 환경에서 실행된다.
        // module은 현재 모듈 자체
        // exports module 에서 내보내는 객체 최초에 빈객체
        // 객체 안에서 this 전역 객체를 가르키는게 아니라 exports를 가리킨다.

        // 모듈 스코프
        // 각각의 독립된 파일들이 독립된 모듈로 실행된다.
        // 다른 파일에서 선언한 변수나 함수는 참조할 수 없다.
        // require 메서드를 사용해서 외부 모듈의 값을 가져와서 사용

        // 함수 스코프의 this는 전역 객체를 가리키게 된다. this는 global를 가리키게 된다.
        // module.exports === exports
        // exports
        // module.exports 새로운 객체를 할당할때
        // exports는 키를 생성해서 할당할때

    }
 )
```
A < B < C
### 모듈 A , 모듈 B , 모듈 C 이렇게 세가지의 모듈을 가지고
> A의 모듈에 B의 모듈을 가져오고 B의 모듈의 C의 모듈을 가져올 것,

> C의 모듈에서는 name이라는 변수를 내보내고
> B의 모듈에는 age는 변수를 내보내고
> A의 모듈에서는 name age를 출력


### 심화 과정은
> 카운터 더하기 기능의 모듈, 빼기 기능의 모듈을 가져와서 계산기 모듈에 가져와서 숫자를 더하고 빼기를 호출할 수 있는 모듈