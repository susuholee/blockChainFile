# 생성자 함수, 재귀 함수

## 재귀함수 
> 재귀 함수는 함수의 내용에서 다시 함수 이름으로 함수의 내용안에서 실행되는것이 반복되는 방식
> for문으로(반복문) 구현 가능한 로직들을 재귀함수로 대부분 작성이 가능하다.
> 재귀 함수를 사용하는 이유는 반복하는 내용의 기능을 여러개로 나눠서 직관적으로 관리할 때
> 사용하는 프로그래밍 패턴중의 하나.

1 + 2 / 3 * 4 + 5 

> 재귀를 작성할 때 더이상 나눠야할 필요가 없을때가 종료 시점
> 문제를 나눠서 기능을 작성하는 경우 패턴을 찾아서 활용해야한다.

## 사용 예)

## 반복문을 사용해서 만든 로직

```js
// 1 ~ 100 더한 수
let result = 0

for(let i = 1; i <= 100; i++){
    result += i;  // 반환하는데 i를 1씩 증가
}
// 100까지 더한수

// 연산식을 사용한 예
let n = 100;
console.log((n / 2) * (n + 1)); // 1부터 100까지 더한 공식
// 알고리즘 풀면서 외우는 것
// 1부터 100까지 더한수 

// 재귀 함수를 사용한 예

// 전역 컨텍스트가 쌓이고
// sum이 호출이 되면서 
// sum이 실행 컨텍스트에 쌓임
// 조건에 맞지 않아서 if문을 읽지 않고 
// 재귀 함수가 호출이 되면서 101이 되면 반환을하고 콜스택에서 해제
// 나머지 값들은 undefined를 반환 

function sum(n, result) {
    if(n === 101) { 
        console.log(result);
        return n;
    }
    sum(n + 1, result + n);

}
sum(1,0);

// 전역 컨텍스트가 쌓이고
// sum 함수 호출되기전에 console.log() 호출이 되면서 sum2실행 컨텍스트 쌓임
// if 문은 부합해서 다음 코드인 sum() 함수가 호출이 되면서 sum 실행 컨텍스트가 쌓임
// n의 값이 101이 될때 까지 반복하면서 재귀 함수를 호출하는데 호출할때 마다 result를 1부터 100까지 더한다.
// n의 값이 101이 되면 더 이상 재귀 함수를 호출하지 않고 이전의 반환된 실행 컨텍스트를 반환한다.
function sum2(n , result) {
    if(n === 101){
        return result;
    }
    return sum(n + 1, result + n);
}

console.log(sum2(1 , 0))
```

> 재귀함수는 잘쓰지 못하면 그냥 반복문으로 돌리는 것보다 못하다. 최적화가 안좋다.

## 재귀 함수의 목적
> 장점으로 반복문을 많이 사용하는 경우 코드의 간결성과 직관성이 증가한다.
> 하지만 단점으로 스택에 함수의 실행컨텍스트가 많이 쌓여서 메모리의 공간이 많이 차지한다.

## 피보나치 수열
> 피보나치 수열은 토끼가 처음에 한쌍이 있고
> 한달이 지나면 한쌍으 토끼가 성장
> 그 이후 한달이 지나면 성장한 토끼가 새끼토끼를 한쌍을 낳는다.
> 그 이후 한달이 또 지나면 성장한 토끼는  또 새끼 토끼 한쌓을 낳고 이전 달의 새끼 토끼 한쌍은 성장한다.
> 이런식으로 계속 증가하는 수열
> 규칙 토끼는 수명이 무한 죽지않는

```js
function fibo(n) {
    if(n === 1 || n === 2) return 1; // 한쌍의 토끼
    return fibo(n - 1) + fibo(n - 2); // 토끼가 성장하고 한쌍의 새끼 토끼를 낳는 값을 구하기 위해서.
}
```

> 수학 공식을 공부할건 아니니깐 프로그래머스, 백준닷컴 등을 풀면서 

### 자바스크립트의 실행 시간 복잡도를 한번 확인해보자.
> 코드의 실행이 얼마나 걸렸는지



// 계산기 구현할때 => 사칙연산 처리할 때

// 45 * 20 엔터키를 누르면
// 짠
> 함수를 사용해서 사칙연산 계산기 구현
> 값을 입력을 받고 다음 연산자를 입력 받고 두 번째 값을 입력 받아서 결과를 출력

> 페어 코딩하는 방법
> 코드를 치는  사람

1. 먼저 calculator 라는 함수를 만들고
2. 각각 사용자의 입력을 받는 변수들이 필요하다.
3. 사칙연산을 만들려면 조건의 부합해야 하는 연산자가 있어야함
4. 문자형을 정수로 변환할려면 parseInt로 받아야한다.
5. case 문으로 작성할 수 있다. 
6. return 하는 반환하는 반환값이 있어야한다. 

```js
function calculator(){ //calculator 함수 생성
    
  const num1 = parseInt(prompt("첫 번째 숫자를 입력하세요:")); 
  const num2 = parseInt(prompt("두 번째 숫자를 입력하세요:"));
  const operator = prompt("연산자를 입력하세요 (+, -, *, /):");

  let result;
 switch(operator){
   case '+':
      return num1 + num2;
   case '-':
      return num1 - num2;
   case '*':
      return num1 * num2;
   case '/':
      return num1 / num2;
   case '%':
      return num1 % num2;
  default:
    console.log("잘못된 연산자입니다.");
    return;
 }
   return result;
}
const result = calculator();
alert("결과: " + result);

```

 0





만약 45000원을 받앗는데 100원 짜리로 몇개인지 알고싶다. 


## 생성자 함수
> 객체를 생성하기위한 함수
> 객체를 생성의 목표를 가지고 있다.
> function 키워드를 사용해서 생성자 함수를 만드는데 이후에 class 
> ES5까지는 function 키워드로 객체의 생성자 함수를 만들었다.
> 만능 nfunction 기능의 작성과 객체의 생성과 여러가지로 사용을 하는 느낌
> ES6 부터 이러한 부분들이 비뀌는 키워드가 많이 추가 되었다.


> ES6
> 화살표 함수 (this 개념), class (객체 생성을 위해서만 만들어진 예약어), 메서드 축약형
```js
// 생성자 함수
// 하나의 인스턴스
// 공장에서 상품을 만드는 기계같은 느낌
// 자동차 객체 하나 생성


// function 안의 this 키워드는 바인딩을 한다는 의미는 바로 위의 객체를 참조한다.
// function에서 this의 키워드는 동적으로 변한다
// 함수를 호출한 위치에서 this를 바인딩한다.
// 코드상의 this를 작성한 영역에서 객체를 참조하는게 화살표 함수


function myinfor(num_ber, addr_ess) { // myCar라는 함수를 정의하고 color, name을 매개변수로 받는다
    this.number = num_ber;  // 새로 생성된 객체의 color 속성에 매개변수로 받은 color 값을 할당
    this.addr_ess =  addr_ess;   // 새로 생성된 객체의 name 속성에 매개변수로 받은 name 값을 할당
}


myinfor("010-0000-0000", "경기도");// this 바인딩이 일어나서
// this가 바인딩 되는 객체는 전역 스코프에 코드를 작성했고
// 브라우저 환경에서 실행되는데 전역객체인 window객체에 키와 값으로 할당된다.
// 이미 만들어진 상품 2개만 들고 있는것.
// 동적으로 생성할 수 없다.
const obj = {
    color : "red",
    name : "GV60"
}

const obj2 = {
    color : "blokc",
    name : "SUB"
}
const obj3 = new myCar("red","black")
// 생성자 함수 사용
// new 예약어 (동적할당) 메모리에 새로운 객체를 만들어서 할당한다.
// [new 예약어] [생성자 함수 실행]


// return을 생성한 객체의 주소를 반환한다. 


```

