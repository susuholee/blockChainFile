# OSI7 계층, HTTP

> 네트워크 통신을 쉽게 이해할 수 있도록 계층을 나눈 개념
> 각 계층이 역할을 가지고 계층간에 데이터를 주고 받기 위해서 네트워크 통신을 단계별로 나눈것.

> `물데네전세표응`

1. 물리 계층 
> 두 컴퓨터가 있다고 가정하면
> 컴퓨터는 파일이나 프로그램들이 모두 0과 1
> 0과 1로 관리한다.
> 두 컴퓨터는 통신을 하기 위해서 전기 신호, 전자 기파 등을 사용해서 데이터를 표현하고 전달해야한다.
> 0101 => 아날로그 신호로 변환해서 ---> 디지털 신호 (0과 1 값으로) 복원해서 데이터를 받을 수 있다.
> 케이블, 허브, 리피터 등의 하드웨어 구성요소로 되어 있다.
> 배달을 한다고 가정하면 물리 계층은 도로의 역할

2. 데이터 링크 계층
> 스위치가 각 네트워크 장치의 MAC 주소를 확인하고 각 모델에게 MAC 주소를 전달g
> 인접한 네트워크에 있는 여러 컴퓨터가 데이터를 주고받을 수 있도록 한다.
> 스위치 : 네트워크에 있는 데이터를 전송하는 하드웨어
> 브리지 : 네트워크 연결해서 데이터의 흐름을 관리한다.
> 랜카드 : 컴퓨터와 네트워크를 연결하는 하드웨어
> MAC 주소 : 네트워크의 장치의 고유 주소
> 배달을 하는 기사가 도로를 통해 배달을 하면서 차선 등을 옮겨다니며 신호등을 보고 사고가 안나게 배달을 진행하는 것

3. 네트워크 계층(소프트웨어 + 하드웨어)
> IP 주소를 사용해서 데이터를 목적지 즉, 컴퓨터로 전송한다.
> 라우터 : 네트워크 `패킷`을 라우팅하는 하드웨어, IP 주소를 기반으로 데이터를 전송한다.
`패킷` : 네트워크에서 데이터를 주고받을 때 사용되는 데이터 조각
> DNS www.naver.com -> IP 
> IP 주소 : 인터넷에서 장치간의 통신을 위해 사용하는 고유의 주소

> 배달기사가 주소를 보고 목적지까지 배달을 하는 과정

4. 전송 계층(소프트웨어)
> TCP/UDP 4계층
> 포트 번호를 사용해서 데이터를 받은 컴퓨터의 최종 목적지 프로세스까지 도달 하도록 한다.
> 운영체제의 커널에 구현되어 있다.

5. 세션 계층(소프트웨어)
> 세션을 설정하고 관리하고 유지
> 로그인 유지나 동기화

6. 표현 계층 
> 데이터의 인코딩 디코딩을 해서 압축이나 암호화를 한다.
> 데이터 포맷 GIF, JPEG 등의 변환
> 암호화 : SSL 등의 보안

7. 응용 계층
> HTTP 는 7계층 
> 유저가 직접 인터넷을 이용하는 것, 상호작용을 하는 계층
> 웹 서비스 : API 통신, 이메일 전송, 파일 전송, 도메인 -> IP로 변환

### OSI7 모델과 TCP/IP 모델
> 이전에는 OSI 7계층 모델을 주로 사용했는데
> 현재는 인터넷이 TCP/IP 모델을 더 많이 사용하게 되었다.
> 시장 점유율 싸움에서 밀려서 TCP/IP가 더 우세했다.


### TCP/IP 
> 기존 TCP 모델은 4계층으로
1. 네트워크 엑세스 계층 : 물리 계층, 데이터 링크 계층 (1계층, 2계층)
2. 인터넷 계층 : IP 주소 기반의 데이터 전달 
3. 전송 계층 : `TCP/UDP` 신뢰성이 있는 데이터를 전송
4. 응용 계층 :  `HTTP` 등의 프로토콜을 제공


### TCP/IP 업데이트 모델
1. 네트워크 인터페이스 계층 : 물리적 전송 매체 등과 하드웨어(이더넷 Wifi 등 포함)
2. 인터넷 계층 : IP주소 기반 패킷 전달 IPV4
3. 전송 계층 : TCP/UDP 등을 지원
4. 응용 계층 : HTTP 웹 소켓 등

### TCP/UDP 
> `프로토콜` 네트워크에서 데이터를 전송 즉 요청 응답을 하기 위해서 규칙을 정한것.
> OSI 모델의 4계층 전송 계층에 해당한다.

### TCP
> 데이터 전송 이전 두 장치가 안정적인 논리적 연결을 했는지 검사 하는 프로토콜

### UDP 
> 데이터의 전송 논리적 연결을 하지않고 데이터 전송을 지향하는 프로토콜
(영상, 스트리밍 게임 등 같은 짧은 대기시간 빠른 속도가 필요한 곳에서 사용)

### TCP
### 3-way-handshake (연결이 일어날 때 일어나는 일)
> 클라이언트가 서버로 요청을 보내면 준비를 하는 단계
> 데이터를 주고 받기 위해서 검증을 하는 것, 검증이 되면 논리적으로 연결이 되었다.

1. SYN 전송  (클라이언트 -> 서버)
> `클라이언트가 서버에 준비됬니?`
> SYN 패킷을 보낸다

2. SYN-ACK 응답 (서버 -> 클라이언트)
> 서버에서 클라이언트에게 `나도 준비됬어 ㅇㅇ`
> 서버에서는 SYN-ACK의 패킷을 보낸다. (서버도 상태가 변환됨)

3. ACK 전송 (서버에서 받은 ACK)
> 클라이언트는 서버에게 메시지를 받아서 `나 잘받았어 우리 이제 데이터를 주고받자.`
> 논리적 연결이 되는 시점.

## 예시
> 클라이언트 -> 서버: SYN 패킷 전송
> 서버 -> 클라이언트 : SYN + ACK (패킷 두개를 합치고 전송)  
> 클라이언트 -> : 응답 받은 값에서 ACK 부분만 서버에게 전달
> 논리적 연결이 된 상태,  값을 데이터를 안전에게 전송할 준비가 끝났다.
> 3-way-handshake 단계가 끝나면
> 데이터를 전송하는 과정이 일어난다.


### 4-way-handshake (연결이 종료될 때 일어나는 일)
> 논리적 연결을 끊는다. 

1. FIN(FINISH) 전송 , 클라이언트가 -> 서버에게
> 클라이언트에서 이제 논리적 연결 종료하자
> `너 데이터 다 보냈니`?
    
2. FIN의 요청을 받고 ACK 응답 (서버-> 클라이언트)
> `서버가 나 아직 응답할게 남아있어`
> 데이터를 전송하지 못했으면 다 처리

3. FIN 전송 (서버 -> 클라이언트)
> 서버에서 클라이언트에게 데이터를 다 보냈고 준비됬다.

4. ACK 응답 (서버에서 클라이언트가 보내준 응답을 받고)
> 서버가 응답을 받고, `나 확인 완전히 종료`

### 한줄 요약
> 3-way-handshake는 논리적 연결 시작 4-way-handshake 논리적 연결 종료
> 데이터를 네트워크에서 주고받을때 TCP 연결 지향 방식으로 데이터를 주고 받는다.

### 바이너리 데이터 
> 사람이 숫자를 셀때 10까지 세는 이유는 손가락이 10개니까
> 컴퓨터는 전기가 들어왔다, 들어오지 않았다. 2진수로 
> 2진수 구하는 공식 : 2로 나누면서 나머지 값을 모두 정렬하면 이진수로 표현된다.
> 2진수는 자리수가 올라가는 때는 1에서 값이 증가하면 자릿수가 증가 2의 값마다 자릿수가 증가한다.
> 2진수는 0 ~ 1 -> 이후 자릿수 증가 

> 1000 이라는 2진수가 있으면 2진수의 하나의 자리수당 비트
> 4비트 `바이트 패딩`
> 컴퓨터가 사용하는 단위 => 비트
> 이 비트가 8개가 모이면 바이트(Byte)라는 컴퓨터의 가장 기본 단위가 된다.

### Binary Data
> 컴퓨터는 기본 0과 1을 표현하고
> 우리는 데이터를 표현할 때 비트나 바이트라는 단위를 많이 사용한다.
> 데이터의 가지수를 표현할 때 사용하는 방법 이라고 보면 된다.
> 12라는 값을 저장해줘, 작성하면 1은 알고 2는 모르는 친구, 2진수로 변환 1100이런식으로 저장
> 숫자 문제 발생 글자는?
> A라는 글자를 2진수로 표현을 어떻게 하지?
> `Character Set 문자 집합` keycode : 컴퓨터는 A와 a가 다르게 받아들인다.
> 영어 문자도 숫자로 표현
> A는 65, a는 97을 2진수로 변환해서 저장
> 사람이 정해놨기 때문에 `문자 집합` 
> 문자 집합 : 문자를 숫자로 표현할 수 있도록 정의한 규칙

### ASCII CODE
> 글자를 표현할 때 8bit만 사용, 글자 하나 작성하면 1byte
> 8bit 중에서 1bit는 오류 체크 용도로 실제로 사용은 7bit
> 1bit는 오류 체크용으로 사용하고 `Parity bit(페리티 비트)`
> 00000000 ~ 11111111 즉 2^7 === 128까지의 아스키 코드는 128가지의 글자를 표현할 수 있게 된것.
> 한글을 제외한 키보드의 자판에 있는 영어와 특수문자만 표현이 가능하다.
> 한글은 1byte로는 표현이 불가능, 알파벳은 1글자, 한글은 1자음으로는 표현할 수 없기 때문에

### 유니코드
> 유니코드는 전새계의 문자를 일관되게 표현할 수 있도록 설계한 표준
> 아스키 코드와 유니코드의 큰 차이점은 용량의 차이
> 글자는 하나당 1byte가 아닌 2byte를 사용한다.

### 16진수
> 2진수와 10진수
> 문자의 길이가 너무 길어서 2진수로 표현하면 비효율적으로 너무 길다. 16진수로 표현 하자.
> 16진수를 구하는 식은
> 1 2 3 4 5 6 7 8 9 A B C D E F 자리수 증가
> 10진수를 16으로 나누고 나머지를 16진수로 표현, 나눈 몫을 0이 될때까지 반복
> 30 -> 1E

### 인코딩의 규칙
> 문자를 숫자로 나타내는 것의 규칙이 있는 것처럼
> 숫자를 바이너리 데이터로 나타내는 규칙이 있다.
> A는 숫자 65 -> 2진수로 표현하면 1000001으로 표현이 된다.
> A12를 컴퓨터가 2진수로 표현하면 10000011100 이렇게 변환을 해서 저장한다.
> 컴퓨터는 어디서 나눠야할지, 어디를 잘라야할지, 몇글자를 잘라야하나 모른다.
> 1000 001100 결과물이 달라질 수 있는것.
> 앞을 8bit씩 뒤를 4bit씩 잘라야 A12글자를 만들수가 있는데
> 그래서 우리는 이런 값을 `문자 인코딩`을 하는것 
> 문자 인코딩 중 하나인 `UTF-8`=> 8의 숫자가 바로 bit를 나타내는 것.
> 12라는 숫자는 4bit로 표현이 가능한데, 문자는 인코딩을 통해서 8bit로 변환을 해야한다.
> 변환하는건 어려운게 아니고, 단순하게 4자리의 숫자를 8자리의 숫자로 표현을 해놓으면 끝
> 0000+1100 자리수를 0으로 채워주는 것 12 => 1000001 00001100 숫자도 문자 인코딩을 통해서 같이 표현이 가능

1. A
> A -> 문자집합 -> 65 -> 1000001(2진수)로 변환 -> 01000001(문자 인코딩)

2. 12
> 12 -> 1100(2진수) -> 00001100

# 3way-handshake, 4way-handshake 방식 꼭 위우기!!
# 응답 받는 헤더 및 
> 반대로 값을 호출하면 디코딩

> 하이픈(-)으로 저장된 문자열은 대괄호 [] 로 접근