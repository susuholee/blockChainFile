# GUI, CLI, 깃(git)

## CLI(Command Line Interface)
> Command Line Interface 

> 콘솔 창을 통래서 프로그램을 실행하는 방식

```sh
cd ..

cd 이동할 폴더명

```

## GUI
> 그래픽 유저 인터페이스
> 화면에 그래픽 요소가 표현되는 형태를 제공

### 쉘
> 터미널을 사용하기 위해 키보드 입력을 통해 명령어를 작성하고 프로그램을 실행한다.
> 폴더와 파일 등을 관리한다.
> 명령을 입력하면 커널이 읽을 수 있는 이진 코드를 변경

### 커널
> 우리가 컴퓨터를 켜면 메모리에 항상 올라가 있는 운영체제
> 하드웨어와 프로그램의 사이에서 인터페이스를 제공하는 역할을 한다.
> 컴퓨터의 자원들을 관리하는 역할

```sh
ctrl + ~  : 터미널 실행 단축키키

mkdir 생성할 폴더이름 : 폴더를 생성하는 명령어
echo 파일의 내용 >  생성할 파일이름 : 파일을 생성하는 명령어
echo nul 파일이름 : 파일을 생성하는데 내용이 포함되지 않는 빈파일

echo mytxt > mytxt.txt 
// 파일 생성
// 파일 수정
echo mytxt2 > mytxt.txt 
// 파일이 이미 있으면 내용을 덮어씌운다.
```
### git(깃)
> git 분산 버전 관리 시스템 (DVCS) 우리 프로젝트의 코드나 파일의 변화를 기록하고
> 이후에 특정 버전의 프로젝트 분기점을 복구할 수 있다.
> 파일이나 코드의 수정 내용을 비교할 수 있다. 쉽게 프로젝트의 버전을 관리할 수 있다는 장점이 있는것.

세이브1
세이브2
세이브3

## git의 버전 관리 시스템 
> PPT 만들때

> 과제 1.PPT      //varseion 1
> 재시험 과제1.PPT   //varseion 2
> 재시험 과제 최종.PPT
> 재시험 과제 진짜 진짜 최종.PPT
> 재시험 과제 진짜 진짜 진짜 최종.PPT
> 재시험 과제 진짜 진짜 진짜 진짜 최종.PPT

> 이렇게 파일을 이름을 바꿔서 저장한 경험이 있을 것이고
> 이전 파일을 찾는게 힘들고 버전관리가 안된다.

> 버전을 스냅샷을 찍어서 관리한다

### 스냅샷
> 특정 시점의 파일이나 코드으 구조를 그대로 즉 데이터를 그대로 지정하는 것.
> 파일 관리하는 프로그램등에서 많이 사용되는 개념 
> 특정 시점의 데이터를 사진을 찍어둔것처럼 해당시점의 데이터를 복원하거나 이전과 비교할 수 있는 기술
- 장점: 버전에 문제가 생긴경우 빠르게 복구가 가능하다. 데이터를 저장하고 보존하는데 강력하다.

### git의 개발 배경
> 리눅스 커널을 개발하던 개발자 토르발스가 소스코드나 파일의 관리를 버전으로 관리하고 싶어서 고민하다가.
> 만들게 된게 git 이전에는 bitkeeeper 라는 것이 있었다.
> 유료 버전이었고 맥 os를 사용할 때 유료 무료로 사용할 수 없는 이슈가 발생을 했고
> 사용자들도 약관을 준수해서 사용을 해야했기 때문에
> bitkeeper의 사용을 중단하고 git을 개발하게 된것.

### git을 사용한 버전 관리
> 혼자서 프로젝트 작업을 하거나 협업을 할때 소스코드를 관리하고 공유할때 이력을 가지고 관리하면서 개발할 수 있다.
> 협업도 간에도 편하게 작업을 할 수 있는 환경
> 우리가 일일히 파일을 관리하고 수정 내용에 주석을 달아서 하나하나 전달하면 번거롭게 가독성도 떨어진다. 주석도 나중에 제거해야 하는데 코드 내용 파악이 불가능하다. 
> 다른 작업자와 협업을 할때 클라우드 저장소와 통신해서 저장소의 내용을 전송하고 다른 작업자가 클라우드 저장소에서 받아서 작업을 진행할 수 있다.
> git을 사용하지 않으면 개발이 불가능할 정도로 많은 개발자가 사용하고 있다.

### git의 분산형 버전 관리
> git은 파일의 이력을 관리해준다. (버전관리의 목적 기능)
> 원격 저장소를 통해서 내용을 전송하고 받을 수 있게 해주는 형태가 분산형 버전관리
> 즉 중앙 집중식 버전 관리가 아닌 각자의 사용자의 저장소의 변경 내용을 다른 개발자와 공유할 수 있다.

### VCS
## VCS 집중형
> 모든 소스 코드를 한곳에 집중해서 저장하는 형태(저장소가 하나)
> 메인 중앙 서버에 팀원들이 모든 소스코드를 통합해서 관리한다.
> 메인 서버가 터지면 관리하는 모든 소스코드가 다 날아간다.
> 프로젝트의 이력이 모두 날아가고 작업을 이어하기 힘들다.
> 파일의 내용을 변경할 때 순서대로 기다리면서 한명씩 변경을 진행해야한다.

## VCS 분산형(git)
> 집중형과 다르게 저장소가 여러개로 버전을 관리할 수 있다.
> 분산 저장소 p2p(peer to peer) 각 팀원들이 서버이자 클라이언트가 될 수 있다.
> 저장소를 하나씩 작업자가 관리를 하고 서버의 문제가 발생하더라도 한명이 문제가 발생해도 작업을 이어나가는데 무리가 없다.

## git의 동작 

1. 초기화 : 로컬에 깃 저장소를 만든다.(폴더 단위)

2. 커밋 : 변경할 프로젝트의 환경을 기록할 준비. (스테이징)

3. 푸쉬 : 기록할 준비가 되어있는 환경을 저장소에 기록

4. 풀 : 저장소에 기록된 버전의 내용을 작업 환경에서 가져온다.
> pull 이후에 push 원격저장소에 분기점이 겹치게 되면 안되니 pull을 먼저 해서 다른 작업자가 작업한 버전의 내용을 가져오고 코드나 파일의 충돌 부분을 수정한 뒤에 push를 해서 버전을 업로드한다. (pull -> push)

5. 병합 : 코드의 이력을 확인하고 이전의 내용과 비교해서 완성될 코드의 내용을 만든다.

### git 


## git Bash
> 윈도우용 깃은 리눅스의 명령어를 실행할 수 있도록 git bash를 제공
> git 명령어는 대부분 git bash 터미널에서 작성을 하자.
> ~ : 루트경로
> comso@ : 컴퓨터 사용자의 이름 

## git 명령어

```sh
# 모든 명령어를 확인
git help -a 

# 보고있는 터미널에서 나가기
vim 명령어 
:q : 화면에서 나가기
:wq : 저장후에 나가기
:wq! : 강제 저장

## git 저장소 초기화
# git init은 폴더의 위치 아무데서나 무분별하게 쓰면 귀찮아진다.
git init  : 프로젝트 폴더안에서 사용
# git 버전관리할 준비가 된것 이 이후부터는 project 폴더 안에 있는 내용들을 감시한다.
# .git 파일이 생성된것을 확인할 수 있다. (숨김파일)

ls : 파일과 폴더 확인 
ls -a : 숨김파일도 모두 확인
ls 경로 : 해당 경로에 있는 파일과 폴더 확인

# 경로에 있는 파일 폴더 삭제
rm -rf A 
# rm 폴더를 삭제

# git 사용할때 유저 깃 사용자의 유저 정보를 이력에 기록하기 위해서 
# .git 저장소에 포함되어 있다. 저장소에 유저정보를 저장한 기록이 없어
# 글로벌 영역에서 가져온다. 설정의 값을 가지고 있는 json파일에서 유저정보를 가져온다.
ls ~/ .gitconfig 

git config --global --list --show-origin

# .git에 유저 정보를 기록
ls .git/config

# 파일의 내용을 출력
cat .git/config

# 편집기로 열어서 확인
code .git/config

## 유저의 내용 추가
git config user.name "blockSuho"
git config user.email "akakak695@naver.com"

# 루트 경로애
echo  nul .gitconfig

# 글로벌 영역 유저 값 생성
git config --global user.name "blockSuho"
git config --global user.email "akakak695@naver.com"

## git 유저 정보를
git init 할때마다 작성할 필요가 없다 값이 없으면 글로벌에 작성된 내용을 사용


## 글로벌 영역에 추가한게 아니고
## 작업하고 있는 워크스페이스로 지정한 디렉터리에 있는 git 저장소
## 스냅샷 기록을 .git 저장소에 이력을 기록한다.

comso@LAPTOP-DAT5TBVP MINGW64 ~/OneDrive - 인덕대학교/바탕 화면/JAVASCRIPT/20250205/project (master)
# (master) 부분은 브런치를 표현하고 있는 곳, 최초의 브런치 하나를 만들어준다. 
# 글로벌 영역에 추가를 해놓고 사용하면 이후에 만드는 최초의 브런치는 이름이 main
git config init.defaultBranch main

# 원격 저장소 추가
git remote add origin https://github.com/susuholee/project.git
# origin 별칭으로 원격 저장소 주소 https://github.com/susuholee/project.git 저장해놓은것

# 원격 저장소에 로컬에 있는 git 저장소의 이력을 업로드 origin은 원격 저장소 주소가 별칭으로 된것.


git push -u origin master
```

## git 저장소 사용
> git init 해서 초기화하면 저장소를 하나 만들어주고 .git
> 최초에 아무것도 없는 상태
> 작업공간을 트래킹해서 추적하게 된다.
> 트래킹하는 내용을 GUI로 볼수있게 익스텐션을 설치하자(소스트리는 git을 cli환경을 경험해보고)

- working directtory 
> 작업을 하는 공간 .git이 있는 경로
> 이 공간만 VCS 내용의 공간
**추적과  비추적**
tracked가 된다는것은 git의 소스코드 관리 대상으로 등록한다.

- stage(대기소)
> 임시로 저장소에 기록하기전 저장하는 공간
> working directtory에서 추가한 코드내용이나 파일의 관리
> 이후에 이 내용을 저장소에 기록한다.

- repo repository
> 기록하는 공간

```sh
git add 파일명 # 해당 파일을 대기소로 보냄
git add . # 현재 경로에 있는 모든 언트래킹된 파일과 수정 내용있는 파일들 모두 대기소로 보냄
# 커밋을 해서 대기소로 올리기 

## 작업 내용
# git commit 만 vim으로 내용을 출력해주고 안에서 작업내용을 작성해서 저장후 종료
# git commit -m : 메시지를 작성하고 커밋
git commit -m "[feat]:  게시판 영역 기능 추가"
# 스테이징의 내용에 추가 스냅샷 이력이 남는것. 커밋 내용을 저장소에 기록 스냅샷 발생


# 커밋을 하고 bcf65706e4447bc7cad469646148da93604c3ef1 
# 커밋 이름으로 작성 되는데
# SHA1의 암호화
# 보안화 해서 문자열을 다루기

git log : 커밋 상태인 내용 확인

git push : 다른 원격 저장소에 이력을 전달할 때 브런치 간에도 

git pull : 원격 저장소 혹은 다른 저장소의 내용을 가져올 때


```


**커밋 메시지 컨벤션**
- feat : 새로운 기능을 추가
- fix : 버그 수정
- docs : 문서를 수정
- style : 코드 스타일 변경 (세미클론이 없어서 수정)
- design : 사용자 웹페이지 UI 디자인 변경 (CSS)
- test : 테스트 코드 작성
- refactor : 코드 리팩토링
- rename : 파일 이름 수정
- remove : 파일을 이동했거나 삭제했다.

### git은 로컬의 저장소 gitHub 클라우드 저장소 
> git과 github의 차이가 뭔가요
> git은 우리 컴퓨터에 저장되는 저장소 
> github는 네트워크에서 저장되는 저장소

### 실습 과제
본인 원격 저장소를 하나 만들고 
원격저장소에 수업한 자료를 하루에 하나씩 
본인이 공부한 내용